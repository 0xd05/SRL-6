(*
Mapwalk
=======

The Mapwalk include contains all Mapwalking functions

*)
{$include_once ../utilities/type.simba}
{$include_once ../minimap/flag.simba}

{*
MM Dot constants
~~~~~~~~~~~~~~~~

.. code-block:: pascal

    const
      MM_NPC = 4369; MM_YELLOW = 4369;
      MM_ITEM = 23; MM_RED = 23;
      MM_PLAYER = 1907997; MM_WHITE = 1907997;
      MM_FRIEND = 5376; MM_GREEN = 5376;
      MM_TEAM = 2171941; MM_BLUE = 2171941;

Used as valid args in getMinimapDots()
*}
const
  MM_NPC = 4369; MM_YELLOW = 4369;
  MM_ITEM = 23; MM_RED = 23;
  MM_PLAYER = 1907997; MM_WHITE = 1907997;
  MM_FRIEND = 5376; MM_GREEN = 5376;
  MM_TEAM = 2171941; MM_BLUE = 2171941;

{*
Directional constants
~~~~~~~~~~~~~~~~

.. code-block:: pascal

    const
      DIR_NORTH = 0;
      DIR_EAST  = 90;
      DIR_SOUTH = 180;
      DIR_WEST  = 270;

Used as valid direction arguments throughout SRL
*}
const
  DIR_NORTH = 0;
  DIR_EAST  = 90;
  DIR_SOUTH = 180;
  DIR_WEST  = 270;

{*
toDirection
~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function toDirection(dir: integer): integer;

Converts a integer to a direction, catching errors and attempts to fix. This
function expects "compass relative" angles. For example: (23, 25, 205).

.. note::

    by Nava2

Example:

.. code-block:: pascal

    dir := toDirection(DIR_EAST);      // -> 90

*}
function toDirection(dir: integer): integer;
begin
    result := round(fixD(dir + 0.0));
end;

(*
makeCompass
~~~~~~~~~~~

.. code-block:: pascal

    function makeCompass(direction: integer): boolean;

Aligns RS to specified direction
   - Enter a degree (23, 25, 205)
      and it will move the compass to that angle.

.. note::

    by Nielsie95 & Nava2

Example:

.. code-block:: pascal

    // using a predefined constant
    makeCompass(DIR_NORTH);

    // using an integer!
    makeCompass(120);

*)
function makeCompass(direction: integer): boolean;
  // Helper function for makeCompass to clean up code
  // Compares Angle and directionDeg to see how far away it is
  function __makeCompass_minCheck(angle, directionDeg: extended): extended;
  begin
    // TODO: Check if fixD could be used to remove some cases..
    result := minE(abs(angle - (directionDeg + 360)), abs((angle + 360) - directionDeg));
    result := minE(abs(angle - directionDeg), result);
  end;
var
  startAngle, angle, directionDeg, i: extended;
  left: boolean;
  mark: Integer;
begin
  result := False;
  startAngle := (getCompassAngleDegrees);
  if ((startAngle < 0) or (not loggedIn)) then exit;

  // convert to direction:
  directionDeg := toDirection(direction)*1.0;

  if (__makeCompass_minCheck(startAngle, directionDeg) <= 8.0) then
    exit(true);

  left := (round((360 - startAngle) + directionDeg) mod 360 <= round((startAngle + 360) - directionDeg) mod 360);
  keyDown((Ord(not left) * 2) + 37);
  wait(10);
  mark := getSystemTime;
  i := 0.0;
  repeat
    wait(16);
    angle:= getCompassAngleDegrees;
    if (((getSystemTime - mark > 6000)  and (i < 1.0)) or
        ((getSystemTime - mark > 10000) and (i < 2.0)) or
        ((getSystemTime - mark > 14000) and (i < 3.0))) then
    begin
      i := i + 1.0;
    end;
  until ((angle < 0) or
    (getSystemTime - mark > 14000) or
    (__makeCompass_minCheck(angle, directionDeg) <= (7.0 + i)));
  if left then
    keyUp(VK_left)
  else
    keyUp(VK_Right);
  wait(10);
  result := (__makeCompass_minCheck(angle, directionDeg) <= (7.0 + i));
end;

(*
setAngle
~~~~~~~~

.. code-block:: pascal

    procedure setAngle(angle: Integer);

Sets the mainscreen at highest\lowest angle, dependant on constant passed.

.. note::

    by Raymond, edit by Naum

Example:

.. code-block:: pascal

    // make the camera the highest!
    setAngle(ANGLE_HIGH);

*)
// Allows one to use clickNorth without waiting 1s every time.
const
  ANGLE_HIGH  = 0;
  ANGLE_LOW   = 1;
  ANGLE_NONE  = 2;

// TODO: Check if 1000ms wait is necessary
procedure setAngle(angle: integer);
begin
  if ((angle = ANGLE_NONE) or (not loggedIn)) then
    exit;

  keyDown((angle * 2) + 38);
  sleep(1000 + random(300));
  keyUp((angle * 2) + 38);
  wait(500 + random(100));
end;

(*
clickNorth
~~~~~~~~~~

.. code-block:: pascal

    procedure clickNorth(angle: integer);

Clicks the compass to make it perfect North. Will set angle at highest depending
on angle. See `setAngle` for more information on the Angle parameter.

.. note::

    by R1ch

Example:

.. code-block:: pascal

    procedure mapWalk();
    begin
      clickNorth(ANGLE_NONE);
      //...

*)
procedure clickNorth(angle: integer);
var
  p: TPoint;
begin
  if (random(4) = 1) then
  begin
    p.Coords(542, 24);
    mouse(p.Rand(15), mouse_Right);
    waitOptionMulti(['ace', 'orth'], 1200);
  end else
    mouse(p.Rand(15), mouse_Left);

  setAngle(angle);
end;

{$DEFINE WALL_ANGLELEFT}

(*
getWallAngle
~~~~~~~~~~~~

.. code-block:: pascal

    function getWallAngle(Ps: TPointArray): extended;

Get's the minimap angle using Walls. Returns Angle in Radians.
Used in maze.scar, but feel free to use for Perfect map aligning projects.

.. note::

    by Wizzup?

Example:
    a := getWallAngle(tpa);

.. code-block:: pascal

*)
function getWallAngle(Ps: TPointArray): extended;
var
   L, I, C: integer;
   ATPA, gATPA: T2DPointArray;
   P, P2: TPoint;
   B: TBox;
begin
  result := -1.0;
  if high(Ps) = -1 then
    exit;
  sortTPAFrom(Ps, point((550 + 703) div 2, 0));  // Sort it from the center.
  {$IFDEF WALL_ANGLELEFT}
  ATPA := splitTPAEx(Ps, 0, 1);   // This turns a PointArray into
                                  // vertical lines
  {$ELSE}
  ATPA := splitTPAEx(Ps, 1, 0); //horizontal lines
  {$ENDIF}

  sortATPASize(ATPA, true);     // longest 'line'.
  L := high(aTPA);
  if L = -1 then
    exit;

  setLength(gATPA, L + 1);
  C := 1;
  gATPA[0] := aTPA[0];
  P := middleTPA(aTPA[0]);        // get middle of the line.

  for I := 1 to L do
  begin // this loops adds any points that are in a dist of 10 pixels.
        // if vert, then x, hori then y (A wall isn't straight.)
    if length(aTPA[I]) < 4 then
      continue;
    P2 := middleTPA(aTPA[I]);
    {$IFDEF WALL_ANGLELEFT}
    if (abs(P.X - P2.X) < 10) then
    {$ELSE}
    if (abs(P.Y - P2.Y) < 10) then
    {$ENDIF}
    begin
      gATPA[C] := aTPA[I];
      C := C + 1;
    end;
  end;
  setLength(gATPA, C);
  setLength(Ps, 0);

  Ps := mergeATPA(gATPA);   //Combine all the points. within 10pix
  B := getTPABounds(Ps);
  sortTPAFrom(Ps, point((B.X1 + B.X2) div 2, 0));   // sort from center

  setLength(ATPA, 0);
  ATPA := splitTPA(Ps, 3);  // split dist three, the left over walls
                            // were all in Ps, and now we split them again.

  setLength(Ps, 0);
  sortATPASize(ATPA, true);   // longest wall.

  Ps := ATPA[0];
  L := high(Ps);   //angle getting
  result := arcTan2(Ps[L].Y -Ps[0].Y, Ps[L].X - Ps[0].X) - (Pi * 0.5);
  {$IFDEF WALL_ANGLELEFT} {$ELSE} result := result + 0.5 * Pi {$ENDIF}
end;

(*
runAway
~~~~~~~

.. code-block:: pascal

    procedure runAway(dir: integer; runFar: boolean; action, waitTime: integer);

- Runs away in minimap related direction, based on north.
- dir can be DIR_NORTH,DIR_EAST,DIR_SOUTH,DIR_WEST, or an angle in degrees (145, 93, 180, etc).
- RunFar will run further than normal.
- Action can be either 1, 2 or 3:

    1. RunAway + wait(waitTime) + RunBack
    2. RunAway + wait(waitTime)
    3. RunBack

.. note::
    waitTime is in milliseconds!

.. note::

    by nielsie95 modified by ZephyrsFury

Example:

.. code-block:: pascal

    if (findFight()) then
    begin
      writeLn('We are in a fight!');
      runAway(DIR_NORTH, true, 1, 2000);
    end;

*)
procedure runAway(dir: integer; runFar: boolean; action, waitTime: integer);
var
  rad, T: Integer;
  deg: extended;
  p: TPoint;
begin
  if (not loggedIn) then exit;

  rad := 30+(int8(runFar)*33);
  deg := toDirection(dir)*1.0;

  if (action < 3) then
  begin
    setRun(true);
    mouseFlag(p.Coords(trunc(rad * sin(radians(fixD(getCompassAngleDegrees + deg))) + MMCX + random(5)),
      trunc(-rad * cos(radians(fixD(getCompassAngleDegrees + deg))) + MMCY + random(5))), 1, 1, -1, false);
    flag();
    wait(500 + random(1500));
    t := getSystemTime;
    while ((getSystemTime - t) < waitTime) and (loggedIn) do
      if (random(5) = 0) then
        idleTime(2000, 500, 1.0)
      else
        wait((waitTime - (getSystemTime - t)) div 5);
  end;

  if (action = 1) or (action = 3) then
  begin
    mouseFlag(p.Coords(trunc(rad * sin(radians(fixD(getCompassAngleDegrees + (deg + 180)))) + MMCX - random(5)),
      trunc(-rad * sos(radians(fixD(getCompassAngleDegrees + (deg + 180)))) + MMCY - random(5))), 1, 1, -1, false);
    flag();
    wait(500 + random(1500));
  end;

  setRun(false);
end;

(*
radialWalk
~~~~~~~~~~~~

.. code-block:: pascal

    function radialWalk(var tpa: TPointArray; cx, cy, theColor, tol, radius: integer; startRadial, endRadial: variant; xMod, yMod: integer = 0): boolean;

Finds TheColor from startRadial to EndRadial for Radius Distance and clicks
Valid Arguments:

    - tpa. result points.
    - startRadial/endRadial. See `toDirection` for information
    - Radius. Distance from the centre of minimap, i.e. how far
      away the mouse clicks. Use numbers 20-72
    - xMod/yMod. The adjustment for each click without finding a flag.

.. note::

    by Nielsie95 & NCDS

Example:

.. code-block:: pascal

    // check if the colour is present
    while (findColor(x,y, roadColor)) do
    begin
      // build a tpa to walk on
      if (radialWalk(tpa, MMCX, MMCY, roadColor, 5, 40, -25, (MMX1-MMCX), 5, 5)) then
        writeln('We're walking');         // this depends how you want to work with the tpa
    end;

*)
function radialWalk(var tpa: TPointArray; cx, cy, theColor, tol, radius, startRadial, endRadial: integer; xMod, yMod: integer = 0): boolean;
var
  sd, ed, direction: integer;
  linear: boolean;
  h, i: integer;
begin
  result := False;
  if (not LoggedIn) then exit;

  sd := toDirection(startRadial);
  ed := toDirection(endRadial);

  //linear walk
  if (sd = ed) then
  begin
    linear := true;
    direction := sd
    if (direction < 50) then
      sd := ((direction + 360) - 50)
    else
      sd := (direction - 50);
    ed := (direction + 50);
    sd := Trunc(FixD(sd + 0.0));
    ed := Trunc(FixD(ed + 0.0));
  end else
    if (sd > ed) then
      swap(sd, ed);

  try
    findColorsTolerance(tpa, theColor, MMX1, MMY1, MMX2, MMY2, tol);
    filterPointsPie(tpa, sd, ed, 10, radius, cx, cy);
    if linear then
      linearSort(tpa, cx, cy, direction, false)
    else
      sortCircleWise(tpa, cx, cy, startRadial, false, startRadial > endRadial);
    result := (length(tpa) > 0);
  except
    srl_Warn('RadialWalkEx', 'An exception has occured', warn_AllVersions); exit;
  end;
  if result then
  begin
    h := high(tpa);
    for i := 0 to h do
      if mouseFlag(tpa[i], xMod, yMod, -1, false) then
      begin
        flag(10);
        exit(true);
      end;
  end;
end;

(*
tpaWalk
~~~~~~~

.. code-block:: pascal

    function tpaWalk(color, tol, offsetX, offsetY: integer; sortFrom: TPoint): boolean;

Uses a simple TPA sorting method to walk to a spot on the minimap.
    * color: the color to be found on the minimap
    * tol: the tolerance on color
    * offsetX: the offset to click on the X coordinate of the found color
    * offsetY: the offset to click on the Y coordinate of the found color
    * sortFrom: the point on the minimap to sort found colors from

.. note::

    by Coh3n

Example:

.. code-block:: pascal

  if (not tpaWalk(1234567, 10, 0, 0, point(MMX1, MMY1)) then
    if (not radialWalkTolerance({parameters here}) then
      writeln('failed to TPA and radial walk');
*)
function tpaWalk(color, tol, offsetX, offsetY: integer = 0; sortFrom: TPoint): boolean;
var
  i: integer;
  tpa: TPointArray;
  p: TPoint;
begin
  result := false;

  if (findColorsTolerance(tpa, color, MMX1, MMY1, MMX2, MMY2, tol)) then
  begin
    sortTPAFrom(tpa, sortFrom);

    for i := 0 to high(tpa) do
    begin
      p := tpa[i];
      p.Inc(offsetX,offsetY);

      if (not onMiniMap(p)) then
        continue;

      mouse(p.Rand(3), mouse_left);

      if (waitFunc(@flag, 50, 3000)) then
        exit(true);
    end;
  end;
end;

(*
getMinimapDots
~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function getMinimapDots(whatDot: integer; x1, y1, x2, y2: integer): TPointArray;

results the dots specified by whatDot in x1, y1, x2, y2.
Usage:

    - MM_NPC, MM_YELLOW = Yellow Dot;
    - MM_TEAM, MM_BLUE = Blue Dot;
    - MM_ITEM, MM_RED = Red Dot;
    - MM_PLAYER, MM_WHITE = White Dot;
    - MM_FRIEND, MM_GREEN = Green Dot;


.. note::

    by Nava2, Rasta magician & NCDS

Example:

.. code-block:: pascal

    count := length(getMinimapDots(MM_FRIEND, MMX1, MMY1, MMX2, MMY2)));
    WriteLn(ToStr(count) + ' friends on the map!');

*)
function getMinimapDots(whatDot: integer; x1, y1, x2, y2: integer): TPointArray; overload;
var
  i, dif, radius, hi, c: integer;
  tpa: TPointArray;
begin
  // confirm valid param
  if (not inIntArray([MM_NPC,MM_ITEM,MM_PLAYER,MM_FRIEND,MM_TEAM],whatDot)) then
  begin
    srl_Warn('getMinimapDots', '"' + whatDot + '" is not a valid dot type', warn_AllVersions);
    exit;
  end;

  freeze;
  radius := max((x2 - x1) div 2, (y2 - y1) div 2);
  findColorsPie(tpa, 65536, 0, 0, 360, 0, radius, x1, y1, x2, y2, (x1 + x2) div 2, (y1 + y2) div 2);
  hi := high(tpa);
  setLength(result, hi+1);
  if (hi < 0) then
  begin
    unFreeze;
    exit;
  end;
  c := 0;
  for i := 0 to hi do
  if (getColor(tpa[i].x - 1, tpa[i].y - 1) - getColor(tpa[i].x, tpa[i].y - 1) = dif) then
  begin
    result[c] := point(tpa[I].x, tpa[i].y - 2);
    inc(c);
  end;
  unFreeze;
  setLength(result, c);
end;

(*
getMinimapDots overload;
~~~~~~~~~~~~~~

.. code-block:: pascal

    function getMinimapDots(whatDot: integer): TPointArray; overload;

results the dots specified by whatDot on the minimap.


.. note::

    by Nava2 & NCDS

Example:

.. code-block:: pascal

    // print the minimap positions on the debug canvas
    debugTPA(getMinimapDots(MM_WHITE));

*)
function getMinimapDots(whatDot: integer): TPointArray; overload;
begin
  result := getMinimapDots(whatDot, MMX1, MMY1, MMX2, MMY2);
end;

(*
getMMDotsOnMS
~~~~~~~~~~~

.. code-block:: pascal

    function getMMDotsOnMS(whatDot: integer): TPointArray;

Using minimap gets all MM dots assumed to be on main Screen and returns it as
a tpa.  You can also use it like Length(GetMMDotsOnMS(whatDot)) to count how
many are actually visable. Returns closes to your position first.  Used with
MMtoMS can be very powerful for searching more precise locations.

.. note::

    by Narcle

Example:

.. code-block:: pascal

   while (length(getMMDotsOnMS(npc)) < 1) and (getSystemTime < timeCheck) do
     wait(100);

*)
function getMMDotsOnMS(whatDot: integer): TPointArray;
var
  i, l, c: integer;
  dots: TPointArray;
  b: TBox;
begin
  b := intToBox(32, 23, 24, 17);//Xtop, Ytop, Xbot, Ybot
  dots := getMinimapDots(whatDot, MMCX - round(b.x1 * 1.3), MMCY - round(b.y1 * 1.3), MMCX + round(b.x2 * 1.3), MMCY + round(b.y2 * 1.3));
  l := length(dots);
  if (l > 0) then
  begin
    setLength(result, l);
    for i := 0 to High(Dots) do
      if inAbstractBox(MMCX - b.x1, MMCY - b.y1, MMCX + b.x1, MMCY - b.y1, MMCX + b.x2, MMCY + b.y2, MMCX - b.x2, MMCY + b.y2, Dots[i].x, Dots[i].y) then
      begin
        result[c] := dots[i];
        inc(c);
      end;
    setLength(result, c);
    sortTPAFrom(result, point(MMCX, MMCY));
  end;
end;

(*
LodestoneScreen
~~~~~~~~~~~~~~~

.. code-block:: pascal

    function BankScreen: boolean;

Finds LodestoneScreen. Returns true if Found.

.. note::

    Author: Home

Example:

.. code-block:: pascal

    If LodestoneScreen then
      WriteLn('Lodestone Network screen is open!');
*)
function LodestoneScreen: boolean;
begin
  result := CountColor(12378347, 172, 26, 345, 42) > 500;
end;


(*
LodestoneTeleport
~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function LodestoneTeleport(Where: String): boolean;

Teleports you to chosen location via Lodestone teleport.

.. note::

    Author: Home

Example:

.. code-block:: pascal

    If CastHomeTeleport then
      Lodestoneteleport('Lumbridge');
*)
function LodestoneTeleport(Where: String): boolean;
var
  tpa: TPointArray;
  TSA: TStringArray;
  CTS, I: Integer;
begin
  If not LoggedIn then exit;
  If not LodestoneScreen then exit;

  CTS := GetColorToleranceSpeed;
  ColorToleranceSpeed(1);

  TSA := ['Lunar Isle', 'Yanille', 'Ardougne', 'Seers Village', 'Catherby', 'Taverley',
          'Burthorpe', 'Edgeville', 'Falador', 'Port Sarim', 'Draynor Village', 'Lumbridge',
          'Varrock', 'Al Kharid', 'Bandit Camp'];

  tpa := [Point(45, 78), Point(160, 262), Point(167, 211), Point(192, 158), Point(223, 181),
          Point(253, 180), Point(251, 145), Point(293, 160), Point(278, 206), Point(276, 249), Point(308, 211),
          Point(327, 243), Point(345, 182), Point(362, 229), Point(326, 297)];

  for I := 0 to 14 do
    if Capitalize(Where) = TSA[I] then
    begin
      MMouse(tpa[I].X, tpa[I].Y, 2, 2);

      if (waitUptextMulti(['Teleport', 'ele', 'ort', 'lepo', 'epor'], 400)) then
      begin
        ClickMouse2(Mouse_left);
        result := true;
      end;
    end;

  ColorToleranceSpeed(CTS);
end;
