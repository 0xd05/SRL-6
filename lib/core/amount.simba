(*
Amount
======

The Amount include contains all kinds of functions to get the amount of items.
Items can be in your bank or in your inventory.

*)

(*
SRL_AREA Constants
~~~~~~~~~~~~~~~~~~

Constants associated with the different finding methods.
These consist of:

- *Inventory*
- *Shop*
- *Deposit Box*
- *Trade Screen*
- *Your Trade Screen*
*)
const
  SRL_AREA_INVENTORY  = 0;
  SRL_AREA_SHOP       = 1;
  SRL_AREA_BANK       = 2;
  SRL_AREA_DEPOSITBOX = 3;
  SRL_AREA_TRADE      = 4;
  SRL_AREA_TRADE_YOUR = 5;

(*

SRL_ITEM_IDENT Consts
~~~~~~~~~~~~~~~~~~~~~

Constants associated with the different finding methods.
These consist of:

- *BITMAP*
- *DTM*
- *COLOUR*, *COLOR*
- *MASK* [*]_

.. [*] Refers to bitmap masks.
*)
const
  SRL_ITEM_IDENT_BITMAP = 0;
  SRL_ITEM_IDENT_DTM    = 1;
  SRL_ITEM_IDENT_COLOUR = 2;  SRL_ITEM_IDENT_COLOR = SRL_ITEM_IDENT_COLOUR;
  SRL_ITEM_IDENT_MASK   = 3;

(*
FindItem
~~~~~~~~

.. code-block:: pascal

	function FindItem(var x, y: Integer; IdentType, Ident: Integer; Area: TBox; Tol: TIntegerArray): Boolean;

Finds an item_IDENT in Area specified by TBox in Area.
Valid IdentTypes are the `SRL_ITEM_IDENT Consts`_.

The tolerance parameter works as follows:

- *Tol[0]*: Color Tolerance;

- *Tol[1]*: Contour Tolerance or minimum Colors to Find to be True.

The main purpose of this and `FindItem`_ are for generalizing helpers in the
different files in these includes. They can easily be used outside for different
generalizations as well, though.

.. note::

	Author: Nava2
  Last Modified: 13 Jan 2011 by Nava2

Example:

.. code-block:: pascal

	var
	  x,y: Integer;
	  b: TBox;
	begin
	  b:= IntToBox(MMX1, MMY1, MMX2, MMY2);
	  if (FindItemEx(x,y, SRL_ITEMIDENT_BITMAP, the_bmp, b, [4])) then
	    Mouse(x,y,5,5,mouse_right);
	end;
*)
function FindItem(var x, y: Integer; IdentType, Ident: Integer; Area: TBox; Tol: TIntegerArray): Boolean;
var
  Pts: TPointArray;
begin
  Result := False;
  SetLength(Tol, 2);
  case IdentType of
    SRL_ITEM_IDENT_MASK:
      Result := FindBitmapMaskTolerance(
          Ident, x, y, Area.x1, Area.y1, Area.x2, Area.y2, Tol[0], Tol[1]
      );

    SRL_ITEM_IDENT_BITMAP:
      Result := FindBitmapToleranceIn(
          Ident, x, y, Area.x1, Area.y1, Area.x2, Area.y2, Tol[0]
      );

    SRL_ITEM_IDENT_DTM:
      Result := FindDTM(Ident, x, y, Area.x1, Area.y1, Area.x2, Area.y2);

    SRL_ITEM_IDENT_COLOUR:
      begin
        FindColorsTolerance(
            Pts, Ident, Area.x1, Area.y1, Area.x2, Area.y2, Tol[0]
        );
        if Tol[1] < 1 then Tol[1] := 1;
        Result := Length(Pts) >= Tol[1];
        if Result then
          MiddleTPAEx(Pts, x, y);
      end;
    else
      SRL_Warn(
          'FindItem', 'Invalid identifier input as IdentType.', warn_ALLVERSIONS
      );
  end;
end;

(*
GetAmount
~~~~~~~~~

.. code-block:: pascal

	function GetAmount(box: TBox): integer;

Returns the amount of an item at in the box 'box'. Returns approximate values
for 'K' and 'M'.

.. note::

	Author: Zeph, N1ke & Narcle
  Last Modified: Unknown

Example:

.. code-block:: pascal

	var
	  i: Integer;
	begin
	  i := GetAmount(InvBox(1)); // Gets the amount in inventory slot 1
    Writeln('Amount = '+toStr(i));
	end;
*)
{$IFNDEF srl_lib_core_gametabs}
{$WARNING SRL-CORE-AMOUNT GAMETABS MUST BE INCLUDED BEFORE AMOUNT}
{$ENDIF}
function GetAmount(box: TBox): integer;
var
  Col: TIntegerArray;
  X, Y, I: Integer;
  B: TBox;
  TPA: TPointArray;
  S: String;
begin
  if (not FindColor(x, y, SRL_OUTLINE_BLACK, box.x1, box.y1, box.x2, box.y2)) then
    exit;

  inc(result);
  Col := [65535, 65278, 16777215, 8453888];

  For I := 0 to High(Col) do
   If FindColor(X, Y, Col[I], box.x1, box.y1, box.x2, box.y2)then
   begin
     FindColors(TPA, Col[i], box.x1, box.y1, box.x2, box.y2);
     B := GetTPABounds(TPA);
     //SMART_DrawBoxEx(False, b, clYellow);
     B := IntToBox(b.x1-2, b.y1-2, b.x2+2, b.y2+2);
     S := GetTextAtExWrap(b.x1, b.y1, b.x2, b.y2, 0, 1, 1, Col[i], 0, StatChars);
     Result := StrToIntDef(ExtractFromStr(s, numbers), 1);
     Case I of
       2: Result := Result * 1000;
       3: Result := Result * 1000000;
     end;
     Exit;
   end;
end;

(*
AreaInfo
~~~~~~~~

.. code-block:: pascal

	function AreaInfo(area: Integer): srl_TItemInterface;

Returns info on certain interfaces as an `srl_TItemInterface Record`_.
Row and col amounts, startcoords, sizes for inventory, banks, shop, ...
Valid Areas:
  - SRL_AREA_INVENTORY
  - SRL_AREA_SHOP
  - SRL_AREA_BANK
  - SRL_AREA_DEPOSITBOX
  - SRL_AREA_TRADE
  - SRL_AREA_TRADE_YOUR

.. note::

	Author: masquerader and Nava2
  Last Modified: 13 Jan 2011 by Nava2

Example:

.. code-block:: pascal

	var
	  info: srl_TItemInterface;
  begin
    info := AreaInfo(SRL_AREA_INVENTORY);
	end;
*)
function AreaInfo(area: Integer): srl_TItemInterface;
begin
  case area of
    SRL_AREA_INVENTORY:
      with Result do
      begin
        start := Point(560, 212);

        rowsize := 36;
        colsize := 42;

        colnumber := 4;
        rownumber := 7;

        //valid := @isInventoryPresent;  //FIX
      end;

    SRL_AREA_SHOP:
      with Result do
      begin
        start := Point(63, 97);

        rowsize := 55;
        colsize := 39;

        colnumber := 10;
        rownumber := 4; //?

        valid := @ShopScreen;
      end;

    SRL_AREA_BANK:
      with Result do
      begin
        start := Point(35, 91);

        rowsize := 44;
        colsize := 44;

        colnumber := 10;
        rownumber := 5;

        valid := @BankScreen;
      end;

    SRL_AREA_DEPOSITBOX:
      with Result do
      begin
        start := Point(97,60);

        rowsize := 48;
        colsize := 50;

        colnumber := 7;
        rownumber := 4;

        valid := @DepositScreen;
      end;

    SRL_AREA_TRADE:
      with Result do
      begin
        start := Point(310, 75);

        rowsize := 32;
        colsize := 49;

        colnumber := 4;
        rownumber := 7;

        valid := @TradeScreen; // ????
      end;

    SRL_AREA_TRADE_YOUR:
      with Result do
      begin
        start := Point(24, 75);

        rowsize := 32;
        colsize := 49;

        colnumber := 4;
        rownumber := 7;

        valid := @TradeScreen; //????
      end;
    else
      srl_Warn(
        'AreaInfo', toStr(Area)+' is an invalid option', warn_AllVersions
      );
  end;
end;

(*
CheckArea
~~~~~~~~~

.. code-block:: pascal

	function CheckArea(area: String): Boolean;

Checks if the given area is opened.

.. note::

	Author: masquerader
  Last Modified: Unknown by EvilChicken

Example:

.. code-block:: pascal

	if (CheckArea('shop')) then
    writeln('Shop is open!');
*)
function CheckArea(area: Integer): Boolean;
begin
  Result := false;
  case area of
    SRL_AREA_INVENTORY:
      begin
        Result := (BankScreen) or (ShopScreen) or (TradeScreen);  // ... FIX
        if (not(Result)) then Result := GameTab(tab_Inv);
      end;
    SRL_AREA_SHOP:
      Result := ShopScreen;
    SRL_AREA_BANK:
      Result := BankScreen;
    SRL_AREA_DEPOSITBOX:
      Result := DepositScreen;
    SRL_AREA_TRADE, SRL_AREA_TRADE_YOUR:
      Result := (TradeScreen); // ... FIX
    else
      srl_Warn(
        'CheckArea', toStr(Area) + ' is an invalid option.', warn_AllVersions
      );
  end;
  if (Result = False) then
    WriteLn('PROBLEM: ' + toStr(Area) + ' interface not open');
end;

(*
ItemCoordinates
~~~~~~~~~~~~~~~

.. code-block:: pascal

	function ItemCoordinates(Area, ItemType, Item_IDENT: Integer; Tol: TIntegerArray): TPointArray;

Returns a TPA with the positions of all occurances of Item_IDENT.

Parameters:

- Area:

  See `SRL_ITEMINT Consts`_

- ItemType:

  See `SRL_ITEM_IDENT Consts`_

- Item_IDENT:

  name/value of your dtm/bmp/color/bmpmask.

- Tol:
	
	+ *SRL_ITEM_IDENT_DTM*: [][#]_.
	
	+ *SRL_ITEM_IDENT_BITMAP*: [BMPTol].
	
	+ *SRL_ITEM_IDENT_COLOUR*: [COLOUR Tol, Minimum Colour Count].
	
	+ *SRL_ITEM_IDENT_MASK*: [BMPTol, ContourTol].

.. note::

	by masquerader modified by ZephyrsFury

Example:

.. code-block:: pascal

.. note::

	Modified: 13 Jan 2011 - Nava2

.. [#] DTMs do not have a *global* tolerance, its all done per point.

*)
function ItemCoordinates(Area, ItemType, Item_IDENT: Integer; Tol: TIntegerArray): TPointArray;
var
  info: srl_TItemInterface;
  x1, y1, x2, y2: Integer;
  itemx, itemy, L: Integer;
  row, col: Integer; // ... FIX
begin
  if (CheckArea(area)) then
  begin
    info := AreaInfo(area);
    SetLength(Result, info.rownumber * info.colnumber);
    for row := 0 to info.rownumber-1 do
      for col := 0 to info.colnumber-1 do
      begin
        x1 := info.start.x + col * info.colsize;
        y1 := info.start.y + row * info.rowsize;
        x2 := x1 + info.colsize;
        y2 := y1 + info.rowsize;
        if (FindItem(Itemx, Itemy, ItemType, Item_IDENT, x1, y1, x2, y2, Tol)) then // ... FIX
        begin
          Result[L].x := ItemX;
          Result[L].y := ItemY;
          Inc(L);
        end;
      end;
  end;
  SetLength(Result, L);
end;

(*
CountItemsIn
~~~~~~~~~~~~

.. code-block:: pascal

	function CountItemsIn(area, ItemType, Item_IDENT: Integer; Tol: TIntegerArray): Integer;

Counts the number of items found within the Area. (Does not count stacks)
Parameters are exactly the same as ItemCoordinates.

.. note::

	Author: masquerader
  Last Modified: Unknown by ZephyrsFury

Example:

.. code-block:: pascal

  var
    itemsFound: integer;
  begin
	  itemsFound := CountItemsArea(SRL_AREA_INVENTORY);
    writeln('Items found: '+toStr(itemsFound));
  end;
*)
function CountItemsIn(area, ItemType, Item_IDENT: Integer; Tol: TIntegerArray): Integer;
begin
  Result := Length(ItemCoordinates(Area, ItemType, Item_IDENT, Tol));
end;

(*
CountItemsArea
~~~~~~~~~~~~~~

.. code-block:: pascal

	function CountItemsArea(area: string): Integer;

Counts the number of items (no matter which item) found in the given area. Looks
for the black outline color.

.. note::

	Author: masquerader
  Last Modified: Unknown

Example:

.. code-block:: pascal

  var
    itemsFound: integer;
  begin
	  itemsFound := CountItemsArea('inv');
    writeln('Items found: '+toStr(itemsFound));
  end;
*)
function CountItemsArea(area: Integer): Integer;
begin
  Result := CountItemsIn(
      area, SRL_ITEM_IDENT_COLOUR, srl_OUTLINE_BLACK,  [0, 1]
    );
end;

(*
ItemAmount
~~~~~~~~~~

.. code-block:: pascal

	function ItemAmount(area, ItemType, Item_IDENT: Integer; Tol: TIntegerArray): Integer;

Counts the number of items found with a color in a certain area. (Counts stacks)
Parameters are exactly the same as ItemCoordinates.

.. note::

	Author: masquerader
  Modified: Unknown by ZephyrsFury

Example:

.. code-block:: pascal

  var
    itemsFound: integer;
  begin
	  itemsFound := ItemAmount(SRL_AREA_INVENOTORY, SRL_ITEM_IDENT_DTM, dtm_Ore, []);
    writeln('Ore found: '+toStr(itemsFound));
  end;
*)
function ItemAmount(area, ItemType, Item_IDENT: Integer; Tol: TIntegerArray): Integer;
var
  areaInfo: srl_TItemInterface;
  Coords: TPointArray;
  i, h: Integer;
begin
  areaInfo := areaInfo(area);

  Coords := ItemCoordinates(Area, ItemType, Item, Tol);
  h := High(Coords);
  for i := 0 to h do
    Result := Result + GetAmountBox(IntToBox(Coords[i].x - floor(areaInfo.rowSize / 2),
                                             Coords[i].y - floor(areaInfo.colSize / 2),
                                             Coords[i].x + floor(areaInfo.rowSize / 2),
                                             Coords[i].y + floor(areaInfo.colSize / 4)));
end;

(*
FindCoins
~~~~~~~~~

.. code-block:: pascal

	function FindCoins(var X, Y: Integer; Area: string): Boolean;

Returns true if coins are found in the given area (Area). If found, stores their
coordinates in X, Y.

.. note::

	Author: ZephyrsFury
  Last Modified: Unknown

Example:

.. code-block:: pascal

  var
    x, y: integer;
  begin
    if (FindCoins(x, y, 'inv')) then
      writeln('Coins found: '+toStr(GetAmount(x, y)));
  end;
*)
function FindCoins(var X, Y: Integer; Area: Integer): Boolean;
var
  B: TBox;
  CTS, I, J, H, L: Integer;
  Pts, tPts: TPointArray;
  ATPA: T2DPointArray;
  V: array [0..1] of TVariantArray;
  hMod, sMod: Extended;
begin
  case Area of // ... FIX
    SRL_ITEMINT_INVENTORY:
      B := IntToBox(MIX1, MIY1, MIX2, MIY2);
    SRL_ITEMINT_BANK:
      B := IntToBox(MBx1, MBy1, MBx2, MBy2);
    SRL_ITEMINT_TRADE:
      B := IntToBox(323, 73, 509, 302);
    SRL_ITEMINT_TRADE_YOUR:
      B := IntToBox(9, 73, 196, 302);
    else
      srl_warn('FindCoins', 'Invalid Area passed.', warn_AllVersions);
  end;
  V[0] := [1606307, 4, 0.09, 1.32]; //Darker colour (top of coins)
  V[1] := [2209251, 8, 0.04, 1.08]; //Lighter colour (rest of the coins)
  CTS := GetToleranceSpeed;
  GetToleranceSpeed2Modifiers(hMod, sMod);
  SetColorToleranceSpeed(2);
  SetLength(tPts, 0);
  try
    for I := 0 to 1 do
    begin
      SetToleranceSpeed2Modifiers(V[I][2], V[I][3]);
      FindColorsTolerance(Pts, V[I][0], B.X1, B.Y1, B.X2, B.Y2, V[I][1]);
      if (Length(Pts) < 10) then Exit;
      ATPA := SplitTPAEx(Pts, 10, 10);
      h := High(ATPA);
      L := High(tPts) + 1;
      SetLength(tPts, L + h + 1);
      for J := 0 to H do
        tPts[L + j] := MiddleTPA(ATPA[J]);
    end;
    ATPA := SplitTPAEx(tPts, 20, 20);
    H := High(ATPA);
    for I := 0 to H do
      if (High(ATPA[I]) = 1) then
        Break;
    if (I > H) then Exit;
    Result := True;
    MiddleTPAEx(ATPA[I], X, Y);
  finally
    SetColorToleranceSpeed(CTS);
    SetToleranceSpeed2Modifiers(hMod, sMod);
  end;
end;

(*
CoinAmount
~~~~~~~~~~

.. code-block:: pascal

	function CoinAmount(Area: string): Integer;

Returns the amount of coins found in the given area.

.. note::

	Author: ZephyrsFury
  Last Modified: Unknown

Example:

.. code-block:: pascal

  writeln('Coins found: '+toStr(CoinAmount('inv')));
*)
function CoinAmount(Area: Integer): Integer;
var
  cx, cy: Integer;
begin
  if (FindCoins(cx, cy, Area)) then
    Result := GetAmount(cx, cy);
end;

