(*
Amount
======

The Amount include contains all kinds of functions to get the amount of items.
Items can be in your bank or in your inventory.

*)

const
  SRL_AREA_INVENTORY  = 0;
  SRL_AREA_SHOP       = 1;
  SRL_AREA_BANK       = 2;
  SRL_AREA_DEPOSITBOX = 3;
  SRL_AREA_TRADE      = 4;
  SRL_AREA_TRADE_YOUR = 5;

(*

SRL_ITEM_IDENT Consts
~~~~~~~~~~~~~~~~~~~~~

Constants associated with the different finding methods.
These consist of:

- *BITMAP*

- *DTM*

- *COLOUR*, *COLOR*

- *MASK* [*]_

.. [*] Refers to bitmap masks.

*)
const
  SRL_ITEM_IDENT_BITMAP = 0;
  SRL_ITEM_IDENT_DTM    = 1;
  SRL_ITEM_IDENT_COLOUR = 2;  SRL_ITEM_IDENT_COLOR = SRL_ITEM_IDENT_COLOUR;
  SRL_ITEM_IDENT_MASK   = 3;

(*
FindItemEx
~~~~~~~~~~

.. code-block:: pascal

	function FindItemEx(var x, y: Integer; IdentType, Ident: Integer; Area: TBox; Tol: TIntegerArray): Boolean;

Finds an item_IDENT in Area specified by TBox in Area.
Valid IdentTypes are the `SRL_ITEM_IDENT Consts`_.

The tolerance parameter works as follows:

- *Tol[0]*: Color Tolerance;

- *Tol[1]*: Contour Tolerance or minimum Colors to Find to be True.

The main purpose of this and `FindItem`_ are for generalizing helpers in the
different files in these includes. They can easily be used outside for different
generalizations as well, though.

.. note::

	by Nava2

Example:

.. code-block:: pascal

	var
	  x,y: Integer;
	  b: TBox;
	begin
	  b:= IntToBox(MMX1, MMY1, MMX2, MMY2);
	  if (FindItemEx(x,y, SRL_ITEMIDENT_BITMAP, the_bmp, b, [4])) then
	    Mouse(x,y,5,5,mouse_right);
	end;

.. note::

	Modified: 13 Jan 2011 - Nava2
*)
function FindItem(var x, y: Integer; IdentType, Ident: Integer; Area: TBox; Tol: TIntegerArray): Boolean;
var
  Pts: TPointArray;
begin
  Result := False;
  SetLength(Tol, 2);
  case IdentType of
    SRL_ITEM_IDENT_MASK:
      Result := FindBitmapMaskTolerance(
          Ident, x, y, Area.x1, Area.y1, Area.x2, Area.y2, Tol[0], Tol[1]
      );

    SRL_ITEM_IDENT_BITMAP:
      Result := FindBitmapToleranceIn(
          Ident, x, y, Area.x1, Area.y1, Area.x2, Area.y2, Tol[0]
      );

    SRL_ITEM_IDENT_DTM:
      Result := FindDTM(Ident, x, y, Area.x1, Area.y1, Area.x2, Area.y2);

    SRL_ITEM_IDENT_COLOUR:
      begin
        FindColorsTolerance(
            Pts, Ident, Area.x1, Area.y1, Area.x2, Area.y2, Tol[0]
        );
        if Tol[1] < 1 then Tol[1] := 1;
        Result := Length(Pts) >= Tol[1];
        if Result then
          MiddleTPAEx(Pts, x, y);
      end;
    else
      SRL_Warn(
          'FindItem', 'Invalid identifier input as IdentType.', warn_ALLVERSIONS
      );
  end;
end;

(*
GetAmount
~~~~~~~~~

.. code-block:: pascal

	function GetAmount(box: TBox): integer;

Returns the amount of an item found in the box 'box'.

.. note::

	by Zeph, N1ke & Narcle

Example:

.. code-block:: pascal

.. note::

	Modified: Sept. 21, 2011 by Coh3n
*)
{$IFNDEF srl_lib_core_gametabs}
{$WARNING SRL-CORE-AMOUNT GAMETABS MUST BE INCLUDED BEFORE AMOUNT}
{$ENDIF}
function GetAmount(box: TBox): integer;
var
  Col: TIntegerArray;
  X, Y, I: Integer;
  B: TBox;
  TPA: TPointArray;
  S: String;
begin
  if (not FindColor(x, y, SRL_OUTLINE_BLACK, box.x1, box.y1, box.x2, box.y2)) then
    exit;

  inc(result);
  Col := [65535, 65278, 16777215, 8453888];

  For I := 0 to High(Col) do
   If FindColor(X, Y, Col[I], box.x1, box.y1, box.x2, box.y2)then
   begin
     FindColors(TPA, Col[i], box.x1, box.y1, box.x2, box.y2);
     B := GetTPABounds(TPA);
     //SMART_DrawBoxEx(False, b, clYellow);
     B := IntToBox(b.x1-2, b.y1-2, b.x2+2, b.y2+2);
     S := GetTextAtExWrap(b.x1, b.y1, b.x2, b.y2, 0, 1, 1, Col[i], 0, StatChars);
     Result := StrToIntDef(ExtractFromStr(s, numbers), 1);
     Case I of
       2: Result := Result * 1000;
       3: Result := Result * 1000000;
     end;
     Exit;
   end;
end;

(*
AreaInfo
~~~~~~~~

.. code-block:: pascal

	function AreaInfo(area: Integer): srl_TItemInterface;

Returns info on certain interfaces as an `srl_TItemInterface Record`_.
Row and col amounts, startcoords, sizes for inventory, banks, shop, ...

.. note::

	by masquerader and Nava2

Example:

.. code-block:: pascal

.. note::

	Modified: 13 Jan 2011 - Nava2
*)
function AreaInfo(area: Integer): srl_TItemInterface;
begin
  case area of
    SRL_AREA_INVENTORY:
      with Result do
      begin
        start := Point(560, 212);

        rowsize := 36;
        colsize := 42;

        colnumber := 4;
        rownumber := 7;

        //valid := @isInventoryPresent;  //FIX
      end;

    SRL_AREA_SHOP:
      with Result do
      begin
        start := Point(63, 97);

        rowsize := 55;
        colsize := 39;

        colnumber := 10;
        rownumber := 4; //?

        valid := @ShopScreen;
      end;

    SRL_AREA_BANK:
      with Result do
      begin
        start := Point(35, 91);

        rowsize := 44;
        colsize := 44;

        colnumber := 10;
        rownumber := 5;

        valid := @BankScreen;
      end;

    SRL_AREA_DEPOSITBOX:
      with Result do
      begin
        start := Point(97,60);

        rowsize := 48;
        colsize := 50;

        colnumber := 7;
        rownumber := 4;

        valid := @DepositScreen;
      end;

    SRL_AREA_TRADE:
      with Result do
      begin
        start := Point(310, 75);

        rowsize := 32;
        colsize := 49;

        colnumber := 4;
        rownumber := 7;

        valid := @TradeScreen; // ????
      end;

    SRL_AREA_TRADE_YOUR:
      with Result do
      begin
        start := Point(24, 75);

        rowsize := 32;
        colsize := 49;

        colnumber := 4;
        rownumber := 7;

        valid := @TradeScreen; //????
      end;
    else
      srl_Warn(
        'AreaInfo', toStr(Area)+' is an invalid option', warn_AllVersions
      );
  end;
end;

(*
CheckArea
~~~~~~~~~

.. code-block:: pascal

	function CheckArea(area: Integer): Boolean;

Checks if the given interface is opened.

.. note::

	by masquerader, and EvilChicken!

Example:

.. code-block:: pascal

.. note::

	Modified: 13 Jan 2011 - Nava2

*)
function CheckArea(area: Integer): Boolean;
begin
  Result := false;
  case area of
    SRL_AREA_INVENTORY:
      begin
        Result := (BankScreen) or (ShopScreen) or (TradeScreen);  // ... FIX
        if (not(Result)) then Result := GameTab(tab_Inv);
      end;
    SRL_AREA_SHOP:
      Result := ShopScreen;
    SRL_AREA_BANK:
      Result := BankScreen;
    SRL_AREA_DEPOSITBOX:
      Result := DepositScreen;
    SRL_AREA_TRADE, SRL_AREA_TRADE_YOUR:
      Result := (TradeScreen); // ... FIX
    else
      srl_Warn(
        'CheckArea', toStr(Area) + ' is an invalid option.', warn_AllVersions
      );
  end;
  if (Result = False) then
    WriteLn('PROBLEM: ' + toStr(Area) + ' interface not open');
end;

(*
ItemCoordinates
~~~~~~~~~~~~~~~

.. code-block:: pascal

	function ItemCoordinates(Area, ItemType, Item_IDENT: Integer; Tol: TIntegerArray): TPointArray;

Returns a TPA with the positions of all occurances of Item_IDENT.

Parameters:

- Area:

  See `SRL_ITEMINT Consts`_

- ItemType:

  See `SRL_ITEM_IDENT Consts`_

- Item_IDENT:

  name/value of your dtm/bmp/color/bmpmask.

- Tol:
	
	+ *SRL_ITEM_IDENT_DTM*: [][#]_.
	
	+ *SRL_ITEM_IDENT_BITMAP*: [BMPTol].
	
	+ *SRL_ITEM_IDENT_COLOUR*: [COLOUR Tol, Minimum Colour Count].
	
	+ *SRL_ITEM_IDENT_MASK*: [BMPTol, ContourTol].

.. note::

	by masquerader modified by ZephyrsFury

Example:

.. code-block:: pascal

.. note::

	Modified: 13 Jan 2011 - Nava2

.. [#] DTMs do not have a *global* tolerance, its all done per point.

*)
function ItemCoordinates(Area, ItemType, Item_IDENT: Integer; Tol: TIntegerArray): TPointArray;
var
  info: srl_TItemInterface;
  x1, y1, x2, y2: Integer;
  itemx, itemy, L: Integer;
  row, col: Integer; // ... FIX
begin
  if (CheckArea(area)) then
  begin
    info := AreaInfo(area);
    SetLength(Result, info.rownumber * info.colnumber);
    for row := 0 to info.rownumber-1 do
      for col := 0 to info.colnumber-1 do
      begin
        x1 := info.start.x + col * info.colsize;
        y1 := info.start.y + row * info.rowsize;
        x2 := x1 + info.colsize;
        y2 := y1 + info.rowsize;
        if (FindItem(Itemx, Itemy, ItemType, Item_IDENT, x1, y1, x2, y2, Tol)) then // ... FIX
        begin
          Result[L].x := ItemX;
          Result[L].y := ItemY;
          Inc(L);
        end;
      end;
  end;
  SetLength(Result, L);
end;

(*
CountItemsIn
~~~~~~~~~~~~

.. code-block:: pascal

	function CountItemsIn(area, ItemType, Item_IDENT: Integer; Tol: TIntegerArray): Integer;

Counts the number of items found within the Area. (Does not count stacks)
Parameters:

- Area:

  See `SRL_ITEMINT Consts`_

- ItemType:

  See `SRL_ITEM_IDENT Consts`_

- Item_IDENT:

  Name/value of your dtm/bmp/color/mask.

- Tol:
	
	+ *SRL_ITEM_IDENT_DTM*: [][#]_.

	+ *SRL_ITEM_IDENT_BITMAP*: [BMPTol].

	+ *SRL_ITEM_IDENT_COLOUR*: [COLOUR Tol, Minimum Colour Count].

	+ *SRL_ITEM_IDENT_MASK*: [BMPTol, ContourTol].

.. note::

	by masquerader modified by ZephyrsFury

Example:

.. code-block:: pascal

.. note::
	Modified: Unknown

.. [#] DTMs do not have a *global* tolerance, its all done per point.

*)
function CountItemsIn(area, ItemType, Item_IDENT: Integer; Tol: TIntegerArray): Integer;
begin
  Result := Length(ItemCoordinates(Area, ItemType, Item_IDENT, Tol));
end;

(*
CountItemsArea
~~~~~~~~~~~~~~

.. code-block:: pascal

	function CountItemsArea(area: Integer): Integer;

Counts items in a specified area. Does **not** count stacks.

.. note::

	By masquerader

Example:

.. code-block:: pascal

*)
function CountItemsArea(area: Integer): Integer;
begin
  Result := CountItemsIn(
      area, SRL_ITEM_IDENT_COLOUR, srl_OUTLINE_BLACK,  [0, 1]
    );
end;

(*
ItemAmount
~~~~~~~~~~

.. code-block:: pascal

	function ItemAmount(area, ItemType, Item_IDENT: Integer; Tol: TIntegerArray): Integer;

Counts the number of items found with a color in a certain area. (Counts stacks)

Parameters:

- Area:

  See `SRL_ITEMINT Consts`_

- ItemType:

  See `SRL_ITEM_IDENT Consts`_

- Item_IDENT:

  name/value of your dtm/bmp/color/bmpmask.

- Tol:
	
	+ *SRL_ITEM_IDENT_DTM*: [][#]_.

	+ *SRL_ITEM_IDENT_BITMAP*: [BMPTol].

	+ *SRL_ITEM_IDENT_COLOUR*: [COLOUR Tol, Minimum Colour Count].

	+ *SRL_ITEM_IDENT_MASK*: [BMPTol, ContourTol].

.. note::

	by masquerader modified by ZephyrsFury.

Example:

.. code-block:: pascal

.. note::
	Modified: Unknown

*)
function ItemAmount(area, ItemType, Item_IDENT: Integer; Tol: TIntegerArray): Integer;
var
  areaInfo: srl_TItemInterface;
  Coords: TPointArray;
  i, h: Integer;
begin
  areaInfo := areaInfo(area);

  Coords := ItemCoordinates(Area, ItemType, Item, Tol);
  h := High(Coords);
  for i := 0 to h do
    Result := Result + GetAmountBox(IntToBox(Coords[i].x - floor(areaInfo.rowSize / 2),
                                             Coords[i].y - floor(areaInfo.colSize / 2),
                                             Coords[i].x + floor(areaInfo.rowSize / 2),
                                             Coords[i].y + floor(areaInfo.colSize / 4)));
end;

(*
FindCoins
~~~~~~~~~

.. code-block:: pascal

	function FindCoins(var X, Y: Integer; Area: Integer): Boolean;

Finds coins in Area and stores the coords in x and y.

.. note::

	by ZephyrsFury.

Example:

.. code-block:: pascal

	var
	  cx, cy, numCoins: Integer;
	begin
	  if (FindCoins(cx, cy, SRL_ITEMINT_INVENTORY)) then
	    numCoins := getAmount(cx, cy);
	end;

.. note::

	Modified: 13 Jan 2011 - Nava2

*)
function FindCoins(var X, Y: Integer; Area: Integer): Boolean;
var
  B: TBox;
  CTS, I, J, H, L: Integer;
  Pts, tPts: TPointArray;
  ATPA: T2DPointArray;
  V: array [0..1] of TVariantArray;
  hMod, sMod: Extended;
begin
  case Area of // ... FIX
    SRL_ITEMINT_INVENTORY:
      B := IntToBox(MIX1, MIY1, MIX2, MIY2);
    SRL_ITEMINT_BANK:
      B := IntToBox(MBx1, MBy1, MBx2, MBy2);
    SRL_ITEMINT_TRADE:
      B := IntToBox(323, 73, 509, 302);
    SRL_ITEMINT_TRADE_YOUR:
      B := IntToBox(9, 73, 196, 302);
    else
      srl_warn('FindCoins', 'Invalid Area passed.', warn_AllVersions);
  end;
  V[0] := [1606307, 4, 0.09, 1.32]; //Darker colour (top of coins)
  V[1] := [2209251, 8, 0.04, 1.08]; //Lighter colour (rest of the coins)
  CTS := GetToleranceSpeed;
  GetToleranceSpeed2Modifiers(hMod, sMod);
  SetColorToleranceSpeed(2);
  SetLength(tPts, 0);
  try
    for I := 0 to 1 do
    begin
      SetToleranceSpeed2Modifiers(V[I][2], V[I][3]);
      FindColorsTolerance(Pts, V[I][0], B.X1, B.Y1, B.X2, B.Y2, V[I][1]);
      if (Length(Pts) < 10) then Exit;
      ATPA := SplitTPAEx(Pts, 10, 10);
      h := High(ATPA);
      L := High(tPts) + 1;
      SetLength(tPts, L + h + 1);
      for J := 0 to H do
        tPts[L + j] := MiddleTPA(ATPA[J]);
    end;
    ATPA := SplitTPAEx(tPts, 20, 20);
    H := High(ATPA);
    for I := 0 to H do
      if (High(ATPA[I]) = 1) then
        Break;
    if (I > H) then Exit;
    Result := True;
    MiddleTPAEx(ATPA[I], X, Y);
  finally
    SetColorToleranceSpeed(CTS);
    SetToleranceSpeed2Modifiers(hMod, sMod);
  end;
end;

(*
CoinAmount
~~~~~~~~~~

.. code-block:: pascal

	function CoinAmount(Area: Integer): Integer;

Returns the amount of coins in a specified interface.

.. note::

	by ZephyrsFury.

Example:

.. code-block:: pascal

	var
	  numCoins: Integer;
	begin
	  numCoins := CoinAmount(SRL_ITEMINT_TRADE);
	end;

.. note::

	Modified: unknown

*)
function CoinAmount(Area: Integer): Integer;
var
  cx, cy: Integer;
begin
  if (FindCoins(cx, cy, Area)) then
    Result := GetAmount(cx, cy);
end;

