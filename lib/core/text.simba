(*
Text
====

The text file holds functions and procedures that are used in Runescape text
recognition.

*)

{$include_once ../tmp.simba}

(*
findText
~~~~~~~~

.. code-block:: pascal

    function findText(var p: TPoint; txt, fonts: TStringArray; b: TBox; waitTime: integer = 0): boolean;

Uses bitmap masks to find text on the screen. Returns true if the text (txt) of
given fonts (fonts) are found in the specified box (b).  If found, set's the
point (p) to where the top right of the text that is found. Optional parameter
(waitTime, default 0) will wait said ms for text to appear.


.. note::

    by Stupid3ooo, modified by LordJashin & Coh3n
    Last Updated: Feb. 20, 2013 by Coh3n

Example:

.. code-block:: pascal

    var
      p: TPoint;
    begin
      if (findText(p, ['Lobby'], [upCharsEx], MI_BOX)) then
        writeln('Found "Exit to Lobby" text');
      .
      .
      .
    end;
*)
function findText(var p: TPoint; txt, fonts: TStringArray; b: TBox; waitTime: integer = 0): boolean;
var
  s, i, j, t: integer;
begin
  t := (getSystemTime + waitTime);
  p := point(-1, -1);

  repeat
    for i := 0 to high(txt) do
      for j := 0 to high(fonts) do
      begin
        s := bitmapFromText(toStr(txt[i]), toStr(fonts[j]));

        if (b.x1 < 0) then b.x1 := 0;
        if (b.y1 < 0) then b.y1 := 0;

        result := findBitmapMaskTolerance(s, p.x, p.y, b.x1, b.y1, b.x2, b.y2, 30, 30);
        freeBitmap(s);

        if (result) then
          break(3);
      end;

  until(getSystemTime > t);

  if (result) then
    subDebug('findText('+toStr(txt)+'): True, at point '+toStr(p))
  else
    subDebug('findText('+toStr(txt)+'): '+toStr(result));
end;

(*
findTextByColor
~~~~~~~~~~~~~~~

.. code-block:: pascal

    function findTextByColor(var p: TPoint; col, tol: integer; txt, fonts: TStringArray; lookIn: TBox; waitTime: integer = 0): boolean; overload;

Uses TPointArrays to find text on the screen.  Searches for the color (col) with
tolerance (tol) on the screen, then looks for the text (txt) in a TPA created
from the fonts (fonts).  Looks in the box (lookIn) and returns the point found
(p). Returns true if the text is found. If the optional parameter (waitTime) is
set, will wait specified amount of time for the text to be found before returning
false.


.. note::

    by Raymond and Coh3n
    Last Updated: Feb. 20, 2013 by Coh3n

Example:

.. code-block:: pascal

    var
      p: TPoint;
    begin
      if (findTextByColor(p, clWhite, 10, ['Lobby'], [upCharsEx], MI_BOX)) then
        writeln('Found "Exit to Lobby" text');
      .
      .
      .
    end;
*)
function findTextByColor(var p: TPoint; col, tol: integer; txt, fonts: TStringArray; lookIn: TBox; waitTime: integer = 0): boolean; overload;
var
  b: TBox;
  i, j, w, h, t: integer;
  tpaColors, tpaText, matches: TPointArray;
begin
  t := (getSystemTime + waitTime);
  p := point(-1, -1);

  if (not findColorsTolerance(tpaColors, col, lookIn, tol)) then
  begin
    subDebug('findTextByColor: failed to find text color');
    exit(false);
  end;

  repeat
    // loop through the fonts and texts to look for
    for i := 0 to high(txt) do
      for j := 0 to high(fonts) do
      begin
        tpaText := TPAFromText(txt[i], fonts[i], w, h);

        if (tpaColors.findTextIn(h - 1, tpaText, matches)) then
        begin
          // sort the tpa matches and return the top left of the text
          b := tpaText.getBounds();
          matches.sortFromPoint(point(b.x1, b.y1));
          p.x := matches[0].x;
          p.y := matches[0].y;

          result := true;
          break(3);
        end;
      end;

  until(getSystemTime() > t);

  if (result) then
    subDebug('findTextByColor('+toStr(txt)+'): True, at point '+toStr(p))
  else
    subDebug('findTextByColor('+toStr(txt)+'): '+toStr(result));
end;

(*
typeByte
~~~~~~~~

.. code-block:: pascal

    procedure typeByte(k: byte);

Types one character k.

.. note::

    by Mutant Squirrle

Example:

.. code-block:: pascal

    typeByte(VK_ENTER);

*)
procedure typeByte(k: byte);
begin
  {$IFDEF SMART}
  if (k = 13) then
    k := 10;
  {$ENDIF}

  KeyDown(k);
  Wait(10 + Random(50));
  KeyUp(k);
end;

(*
typeSend
~~~~~~~~

.. code-block:: pascal

    procedure typeSend(text: string; pressEnter: boolean = true);

Types text in a human-like way.  Optional parameter 'pressEnter'.  Will press
enter by default.

.. note::

    by SKy Scripter
    Last Updated: January 29th, 2013 by Coh3n

Example:

.. code-block:: pascal

    // to type and press enter
    typeSend('Hello');

    // to type and not press enter
    typeSend('Hello', false);

*)
procedure typeSend(text: string; pressEnter: boolean = true);
var
  i: Integer;
begin
  for i := 1 to Length(Text) do
  begin
    SendKeys(Text[i], 30 + Random(30), 30 + Random(30));
    Wait(40 + Random(40));
  end;

  if (pressEnter) then
    TypeByte(VK_ENTER);
end;

(*
isUptext
~~~~~~~~

.. code-block:: pascal

    function isUptext(txt: TStringArray; waitTime: integer = 50; tol: extended = 0.6): boolean;

Returns true if 'txt' is found in the RS uptext string. Optional parameter
'waitTime' to wait for the text to appear (default 50ms). Optional tolerance
parameter (default 0.6).

.. note::

    by Narcle
    Last Updated: Feb. 21, 2013 by Coh3n

Example:

.. code-block:: pascal

    if (isUptext(['Mine', 'rock'])) then
      writeln('Found uptext!');
*)
{function isUptext(txt: TStringArray; waitTime: integer = 0; tol: extended = 0.6): boolean;
var
  i, t: integer;
  s: string;
begin
  t := (getSystemTime() + waitTime);

  repeat
    s := rs_GetUpText;
    debug('isUptext current uptext: '+s);

    for i := 0 to high(txt) do
      if (stringMatch(txt[i], s, tol)) then
      begin
        subDebug('Found '+txt[i]+' in uptext string: '+s);
        exit(true);
      end;

    wait(10);
  until (getSystemTime() > t);
end;}

{
  type TOptions
  Description: Used to store an RS right click menu.
}
Type
  _TOptions = record
    str: string;
    bounds, bigBox: TBox;
  end;

{*
__getChooseOptions
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function __getChooseOptions(): array of _TOptions;

Gets the text from the options menu.

.. note::

    by Wizzup? & Narcle

Example:

.. code-block:: pascal

*}
function __getChooseOptions(): array of _TOptions;
var
   b, bb: TBox;
   TPA, TPA1, TPA2, tpaText, tpaNotText, tpaShadow: TPointArray;
   ATPA, tmpATPA: T2DPointArray;
   i, l, w, h, bmp, oldTarget, oldCTS: integer;
   menuColors: TIntegerArray;
begin
  oldTarget := getImageTarget();

  // the entire RS client
  getClientDimensions(b.x2, b.y2);
  b := intToBox(0, 0, b.x2 - 1, b.y2 - 1);

  oldCTS := getToleranceSpeed();
  setColorToleranceSpeed(1);

  menuColors := [131843 {black}, 3682593 {top blue}, 3552822 {grey}];
  setLength(ATPA, length(menuColors));

  // find how many of each menu color is found; store in ATPA
  for i := 0 to high(menuColors) do
    findColors(ATPA[i], menuColors[i], b);

  TPA := ATPA.merge();
  ATPA := TPA.split(4);

  // gets the right box of colors on the MS by checking the size of each color's area
  for i := 0 to high(ATPA) do
  begin
    b := ATPA[i].getBounds();

    if ((b.x2 - b.x1) > 90) and ((b.y2 - b.y1) > 18) then
      break;
  end;

  setColorToleranceSpeed(3);

  // get TPAs of the text, around text, and shadow
  findColorsTolerance(tpaText, 4996381, b, 18);
  tpaNotText := tpaText.returnNotInTPA(tpaText.getBounds());
  findColorsTolerance(tpaShadow, 460291, b, 6);

  setColorToleranceSpeed(oldCTS);

  // create a bitmap of size b (the size of the menu)
  bmp := createBitmap(b.x2 - b.x1 + 2, b.y2 - b.y1 + 2);

  // "reset" not text/shadow TPAs so they can be drawn on bmp
  tpaNotText.offset(point(-b.x1, -b.y1));
  tpaShadow.offset(point(-b.x1, -b.y1));

  fastDrawClear(bmp, 0);
  drawTPABitmap(bmp, tpaNotText, clRed);
  drawTPABitmap(bmp, tpaShadow, clPurple);

  ocr_FilterUpTextByCharacteristics(getMufasaBitmap(bmp));
  getBitmapSize(bmp, w, h);

  setTargetBitmap(bmp); // new target for findColors
  setLength(ATPA, h div 16);

  // look for the outlined text on the bitmap
  for i := 0 to high(ATPA) do
    findColors(ATPA[i], clRed, 0, (2 + i * 16), w - 1, (18 + i * 16)); // +2 to y to line it up

  l := high(ATPA);
  sortATPAFromFirstPointY(ATPA, point(w div 2, 0));

  setLength(result, length(ATPA));

  for i := 0 to high(ATPA) do
  begin
    tmpATPA := ATPA[i].split(1, 10); // split one into characters
    sortATPAFromFirstPointX(tmpATPA, point(0, 0));

    result[i].str := tmpATPA.getTextInATPA(5, 'UpCharsEx');
    //writeln(result[i].str);

    bb := ATPA[i].getBounds();
    result[i].bounds := intToBox((bb.x1 + b.x1), (bb.y1 + b.y1), (bb.x2 + b.x1), (bb.y2 + b.Y1));
  end;

  setColorToleranceSpeed(oldCTS);
  setImageTarget(oldTarget);
  freeBitmap(bmp);
end;
