

var
  clWhite = 16777215;
  clBlack = 0;

  clRed   = 255;
  clGreen = 32768;
  clBlue  = 16711680;

  clPurple = 8388736;
  clYellow = 65535;

  maxInt = high(integer);

procedure SortATPAFromFirstPointY(var a: T2DPointArray; const From: TPoint);
var
   i, l: Integer;
   DistArr: TIntegerArray;
begin
  l := high(a);
  if (l < 0) then
    Exit;

  setLength(DistArr, l + 1);
  for i := 0 to l do
  begin
    if (length(a[i]) <= 0) then // prevent out of range errors
      continue;

    DistArr[i] := Round(Sqr(From.y - a[i][0].y));
  end;

  QuickATPASort(DistArr, a, 0, l, True);
end;

procedure SortATPAFromFirstPointX(var a: T2DPointArray; const From: TPoint);
var
   i, l: Integer;
   DistArr: TIntegerArray;
begin
  l := High(a);
  if (l < 0) then
    Exit;

  SetLength(DistArr, l + 1);
  for i := 0 to l do
  begin
    if (length(a[i]) <= 0) then
      continue;

    DistArr[i] := Round(Sqr(From.x - a[i][0].x));
  end;

  QuickATPASort(DistArr, a, 0, l, True);
end;

function JaroWinkler(u, v: String): Double;
var
  a, b, i, j, m, mr, t, l: Integer;
  ut, vt: String;
  uignore, vignore: Array of Integer;
begin
  result := 0.0;

  a := length(u);
  b := length(v);
  mr := ceil(max(a, b) / 2.0) - 1;
  setLength(uignore, a);
  setLength(vignore, b);

  // Calculate "M" (matches)
  m := 0;
  for i := 1 to a do
  begin
    for j := 1 to b do
    begin
      if((u[i] = v[j]) and (uignore[i-1] = 0) and (vignore[j-1] = 0))then
        if(abs(i - j) <= mr)then
        begin
          Inc(m);
          uignore[i-1] := 1;
          vignore[j-1] := 1;
          break;
        end;
    end;
  end;

  // Calculate "T" (transpositions)
  t := 0;
  for i := 0 to a-1 do
    if(uignore[i] = 1)then ut := ut + u[i+1];
  for i := 0 to b-1 do
    if(vignore[i] = 1)then vt := vt + v[i+1];

  for i := 1 to length(ut) do
    if (not (ut[i] = vt[i])) then Inc(t);
  t := round(t / 2);

  // Winkler weighting (this could be removed)
  l := 0;
  for i := 1 to a do
    if(u[i] = v[i])then Inc(l) else break;

  // Answer
  try
    result := (1.0/3)*(  Extended(m)/a  +  Extended(m)/b  +  Extended(m-t)/m);
    result := result + (l * 0.1 * (1.0 - result));
  except
  end;
end;

function StringMatch(FindStr, UpTxt: string; tol: Extended): boolean;
var
  fL, uL, i: integer;
  S: String;
  Hi, J: Extended;
begin
  fL := Length(FindStr);
  uL := Length(UpTxt)+1;
  for i := 1 to uL-fL do
  begin
    J := JaroWinkler(FindStr, Copy(UpTxt, i, fL));
    if J > Hi then
      Hi := J;
  end;
  Result := Hi >= tol;
end;

(*
ArrInStr
~~~~~~~~

.. code-block:: pascal

    function ArrInStr(arrS: TStringArray; str: string): Boolean;

Returns True if the Array is found in the str. Case sensitive.

.. note::

    by Narcle & Nava2

Example:

.. code-block::pascal

*)
function StrArrInStr(arrS: TStringArray; str: string): Boolean;
var
  I, L, H: Integer;
begin
  Result := True;
  L := Low(arrS);    H := High(arrS);
  for I := L to H do
    if Pos(arrS[I], Str) > 0 then
      Exit;
  Result := False;
end;

(*
GridBox
~~~~~~~

.. code-block:: pascal

    function GridBox(slot, columns, rows, w, h, diffX, diffY: integer; starTPoint: TPoint): TBox;

Returns a TBox of the slot 'slot' in a grid created by the other parameters.
Slots start with 0 being the top left of the grid, and counting accross.
    * columns: number of columns in the grid
    * rows: number of rows in the grid
    * w: the width of each box in the grid
    * h: the height of each box in the grid
    * diffX: pixels from center to center (x)
    * diffY: pixels from center to center (y)
    * starTPoint: the center point of the top left box in the grid

.. note::

    | Author: Coh3n
    | Last Modified: Jan. 25th, 2012 by Coh3n

Example:

.. code-block:: pascal

    result := GridBox(Slot, 4, 2, 95, 80, 0, 150, point(110, 100));
*)
function GridBox(slot, columns, rows, w, h, diffX, diffY: integer; startPoint: TPoint): TBox;
begin
  if (slot > (columns * rows)) then
  begin
    writeln('GridBox: Invalid slot: '+toStr(slot));
    exit;
  end;

  result.x1 := (startPoint.x + ((slot mod columns) * diffX) - (w div 2));
  result.y1 := (startPoint.y + ((slot div columns) * diffY) - (h div 2));
  result.x2 := (result.x1 + w);
  result.y2 := (result.y1 + h);
end;

(*
Grid
~~~~

.. code-block:: pascal

    function Grid(columns, rows, w, h, diffX, diffY: integer; starTPoint: TPoint): TBoxArray;

Returns a grid of TBoxes (see GridBox for parameters).

.. note::

    | Author: Coh3n
    | Last Modified: Jan. 25th, 2012 by Coh3n

Example:

.. code-block:: pascal

    SMART_DrawBoxes(false, Grid(5, 10, 20, 20, 25, 25, point(30, 30)), clYellow);
*)
function Grid(columns, rows, w, h, diffX, diffY: integer; starTPoint: TPoint): TBoxArray;
var
  i: integer;
begin
  setLength(result, (columns * rows));

  for i := 0 to high(result) do
    result[i] := GridBox(i, columns, rows, w, h, diffX, diffY, starTPoint);
end;
